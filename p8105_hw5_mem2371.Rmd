---
title: "Homework 5"
author: Megan Marziali
output: github_document
---

```{r}
library(tidyverse)
library(rvest)
library(ggplot2)

knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp = 0.6,
  out.width = "90%"
)

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_color_viridis_d
scale_fill_discrete = scale_fill_viridis_d

set.seed(1)
```

## Problem 1

Read in the data.

```{r}
homicides_df = 
  read_csv("./data/homicides.csv",
           na = "") %>% 
  janitor::clean_names() %>% 
  mutate(
    resolved = case_when(
      disposition == "Closed without arrest" ~ "unsolved",
      disposition == "Open/No arrest" ~ "unsolved",
      disposition == "Closed by arrest" ~ "solved"
      ),
    city_state = str_c(city, state, sep = "_"),
    date = as.Date(paste(reported_date, "01", sep = ""), "%Y%m%d")
  ) %>% 
  select(city_state, resolved) %>% 
  filter(city_state != "Tulsa_AL")
```

The Washington Post data on homicides in 50 large US cities contains `r nrow(homicides_df)` rows and `r ncol(homicides_df)` variables (including the city_state and new date variables, which has been constructed in the above code). The data contains important information regarding homicides, such as the victim's first and last name, race, age, sex, location of incident (including city and state), and the status of the case.

Let's look at this a bit

```{r}
aggregate_df = 
  homicides_df %>% 
  group_by(city_state) %>% 
  summarize(
    hom_total = n(),
    hom_unsolved = sum(resolved == "unsolved")
  )
```

Can I do a prop test for a single city?

```{r}
prop.test(
  aggregate_df %>% filter(city_state == "Baltimore_MD") %>%  pull(hom_unsolved),
  aggregate_df %>% filter(city_state == "Baltimore_MD") %>%  pull(hom_total)) %>% 
  broom::tidy()
```

Try to iterate ...

```{r}
results_df = 
  aggregate_df %>% 
  mutate(
    prop_tests = map2(.x = hom_unsolved, .y = hom_total, ~prop.test(x = .x, n = .y)),
    tidy_tests = map(.x = prop_tests, ~broom::tidy(.x))
  ) %>% 
  select(-prop_tests) %>% 
  unnest(tidy_tests) %>% 
  select(city_state, estimate, conf.low, conf.high)
```


```{r}
results_df %>% 
  mutate(city_state = fct_reorder(city_state, estimate)) %>% 
  ggplot(aes(x = city_state, y = estimate)) +
  geom_point() + 
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high))
```

## Problem 2 ideas ... 

Import one dataset

```{r}
data_1 = read_csv("./lda_data/con_01.csv")
```

```{r}
path_df = 
  tibble(
    path = list.files("lda_data")
  ) %>% 
  mutate(
    path = str_c("lda_data/", path),
    data = purrr::map(path, read_csv)
    ) %>% 
  unnest(data) %>% 
  separate(
    path,
    into = c("file1", "file2", "trt_arm", "id", NA)
  ) %>% 
  select(-file1, -file2) %>% 
  pivot_longer(
    week_1:week_8,
    names_to = "week",
    values_to = "obs"
  ) %>% 
  mutate(
    week = as.numeric(sub(".*_", "", week))
    )
```

```{r}
path_df %>% 
  ggplot(aes(x = week, y = obs, group = id, color = id)) +
  geom_smooth(se = FALSE) +
  facet_grid(. ~ trt_arm)
```

## Problem 3

Need to simulate a sample and conduct a t-test within the function. Then, combine this function with a map statement. The following code is to build the initial function, and make sure it works when setting mu = 0.

```{r}
sim_ttest2 = function(samp_size = 30, mu, sigma = 5) {
  
  sim_data = 
    tibble(
      x = rnorm(n = samp_size, mean = mu, sd = sigma)
    )
  
  sim_data %>% 
    t.test() %>% 
    broom::tidy()
}

sim_results = 
  rerun(10, sim_ttest2(mu = 0)) %>% 
  bind_rows()
```

```{r}
sim_results = 
  rerun(10, sim_ttest2(mu = 0)) %>% 
  bind_rows()
```

The next code chunk sets mu as 0:6, to create a finalized dataset.

```{r}
sim_tres = 
  tibble(
  mu = c(0, 1, 2, 3, 4, 5, 6)
  ) %>% 
  mutate(
    output_lists = map(.x = mu, ~ rerun(10, sim_ttest2(mu = .x))),
    estimate_df = map(output_lists, bind_rows)
  ) %>% 
  select(-output_lists) %>% 
  unnest(estimate_df) %>% 
  rename(mu_hat = estimate) %>% 
  select(mu, mu_hat, p.value) %>% 
  mutate(
    rejected = case_when(
      p.value <= 0.05 ~ "yes",
      p.value > 0.05  ~ "no"
      ))
```

### Plot 1

The plot below illustrates power and the true value of mu.

```{r}
sim_prop = 
  sim_tres %>% 
  group_by(mu, rejected) %>% 
  filter(rejected == "yes") %>% 
  summarise(
    count = n()) %>% 
  mutate(
    prop = count / 10
  )
  
sim_prop %>% 
  ggplot(aes(x = mu, y = prop)) +
  geom_point()
```

## Plot 2

The plot below illustrates the average estimate of mu\hat on the x-axis, and the true value of mu on the y-axis.

```{r}
sim_avg = 
  sim_tres %>%
  group_by(mu) %>%
  summarize(
    mu_avg = sum(mu_hat) / 10
  )

sim_avg %>% 
  ggplot(aes(x = mu, y = mu_avg)) +
  geom_point()
```

